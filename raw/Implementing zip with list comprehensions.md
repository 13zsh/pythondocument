Skip to content

[Lerner Consulting Blog](http://blog.lerner.co.il/)

Thoughts from Reuven Lerner about technology, business, and education

Menu and widgets

[ Follow @reuvenmlerner ](https://twitter.com/reuvenmlerner)

[ Follow @DailyTechVideo ](https://twitter.com/DailyTechVideo)

## More from Reuven

  * [![ebook: Practice Makes Python](http://blog.lerner.co.il/wp-content/uploads/2014/10/3D_book.jpg) ebook: Practice Makes Python](http://PracticeMakesPython.com/ "50 exercises designed to improve your Python" )
  * [![ebook: Practice Makes Regexp](http://blog.lerner.co.il/wp-content/uploads/2020/09/practice-makes-regexp-cover.jpg) ebook: Practice Makes Regexp](http://PracticeMakesRegexp.com/ "50 exercises designed to help you master regexps" )
  * [Lerner Consulting](http://lerner.co.il/)
  * [Reuven's courses and presentations](http://lerner.co.il/courses "Courses, Webinars, videos, and slideshows" )

Search for:

## Recent Posts

  * [Implementing "zip" with list comprehensions](http://blog.lerner.co.il/implementing-zip-list-comprehensions/)
  * [Fun with floats](http://blog.lerner.co.il/fun-with-floats/)
  * [Announcing: An online community for technical trainers](http://blog.lerner.co.il/announcing-online-community-technical-trainers/)
  * [Speedy string concatenation in Python](http://blog.lerner.co.il/speedy-string-concatenation-python/)
  * [Want to learn Chinese?](http://blog.lerner.co.il/win-free-chinese-lessons/)

## Popular Posts

  * Implementing "zip" with list comprehensions
  * [Turning PostgreSQL rows into arrays](http://blog.lerner.co.il/turning-postgresql-rows-arrays-array/ "Turning PostgreSQL rows into arrays" )
  * [Looking in PostgreSQL arrays with ANY](http://blog.lerner.co.il/looking-postgresql-arrays/ "Looking in PostgreSQL arrays with ANY" )
  * [Turning a PostgreSQL array to rows](http://blog.lerner.co.il/turning-postgresql-arrays-rows-unnest/ "Turning a PostgreSQL array to rows" )
  * [Don't use double quotes in PostgreSQL](http://blog.lerner.co.il/quoting-postgresql/ "Don't use double quotes in PostgreSQL" )
  * [In Python, it's all about the attributes](http://blog.lerner.co.il/python-attributes/ "In Python, it's all about the attributes" )
  * [Understanding nested list comprehensions in Python](http://blog.lerner.co.il/understanding-nested-list-comprehensions-in-python/ "Understanding nested list comprehensions in Python" )
  * [If you don't use "with", when does Python close files? The answer is: It depends.](http://blog.lerner.co.il/dont-use-python-close-files-answer-depends/ "If you don't use "with", when does Python close files?  The answer is: It depends." )
  * [Fun with floats](http://blog.lerner.co.il/fun-with-floats/ "Fun with floats" )
  * [Is it hashable? Fun and games with hashing in Python](http://blog.lerner.co.il/is-it-hashable-fun-and-games-with-hashing-in-python/ "Is it hashable? Fun and games with hashing in Python" )

## Recent Comments

  * Larry Bugbee on [Implementing "zip" with list comprehensions](http://blog.lerner.co.il/implementing-zip-list-comprehensions/#comment-32170)
  * Larry Bugbee on [Implementing "zip" with list comprehensions](http://blog.lerner.co.il/implementing-zip-list-comprehensions/#comment-32169)
  * [Stephen Paul Chappell](https://plus.google.com/+StephenChappell) on [Implementing "zip" with list comprehensions](http://blog.lerner.co.il/implementing-zip-list-comprehensions/#comment-32166)
  * [Reuven Lerner](http://lerner.co.il) on [Implementing "zip" with list comprehensions](http://blog.lerner.co.il/implementing-zip-list-comprehensions/#comment-32163)
  * Andrea R on [Implementing "zip" with list comprehensions](http://blog.lerner.co.il/implementing-zip-list-comprehensions/#comment-32162)

## Archives

  * [August 2016](http://blog.lerner.co.il/2016/08/)
  * [May 2016](http://blog.lerner.co.il/2016/05/)
  * [April 2016](http://blog.lerner.co.il/2016/04/)
  * [March 2016](http://blog.lerner.co.il/2016/03/)
  * [February 2016](http://blog.lerner.co.il/2016/02/)
  * [December 2015](http://blog.lerner.co.il/2015/12/)
  * [November 2015](http://blog.lerner.co.il/2015/11/)
  * [October 2015](http://blog.lerner.co.il/2015/10/)
  * [September 2015](http://blog.lerner.co.il/2015/09/)
  * [July 2015](http://blog.lerner.co.il/2015/07/)
  * [June 2015](http://blog.lerner.co.il/2015/06/)
  * [April 2015](http://blog.lerner.co.il/2015/04/)
  * [March 2015](http://blog.lerner.co.il/2015/03/)
  * [February 2015](http://blog.lerner.co.il/2015/02/)
  * [January 2015](http://blog.lerner.co.il/2015/01/)
  * [November 2014](http://blog.lerner.co.il/2014/11/)
  * [October 2014](http://blog.lerner.co.il/2014/10/)
  * [September 2014](http://blog.lerner.co.il/2014/09/)
  * [July 2014](http://blog.lerner.co.il/2014/07/)
  * [May 2014](http://blog.lerner.co.il/2014/05/)
  * [March 2014](http://blog.lerner.co.il/2014/03/)
  * [February 2014](http://blog.lerner.co.il/2014/02/)
  * [January 2014](http://blog.lerner.co.il/2014/01/)
  * [December 2013](http://blog.lerner.co.il/2013/12/)
  * [November 2013](http://blog.lerner.co.il/2013/11/)
  * [October 2013](http://blog.lerner.co.il/2013/10/)

## Categories

  * [Book reviews](http://blog.lerner.co.il/category/book-reviews/) (1) 
  * [Business](http://blog.lerner.co.il/category/business/) (15) 
  * [Education](http://blog.lerner.co.il/category/education/) (8) 
  * [Open source](http://blog.lerner.co.il/category/open-source/) (5) 
  * [PostgreSQL](http://blog.lerner.co.il/category/postgresql/) (9) 
  * [Python](http://blog.lerner.co.il/category/python/) (43) 
  * [Ruby](http://blog.lerner.co.il/category/ruby/) (14) 
  * [Training](http://blog.lerner.co.il/category/training/) (4) 
  * [Uncategorized](http://blog.lerner.co.il/category/uncategorized/) (6) 

## Meta

  * [Register](http://blog.lerner.co.il/wp-login.php?action=register)
  * [Log in](http://blog.lerner.co.il/wp-login.php)
  * [Entries RSS](http://blog.lerner.co.il/feed/)
  * [Comments RSS](http://blog.lerner.co.il/comments/feed/)
  * [WordPress.org](https://wordpress.org/ "Powered by WordPress, state-of-the-art semantic personal publishing platform." )

# Implementing "zip" with list comprehensions

[![zipper](http://i1.wp.com/blog.lerner.co.il/wp-content/uploads/2016/08/zippe
r3.png?resize=150%2C300)](http://i1.wp.com/blog.lerner.co.il/wp-
content/uploads/2016/08/zipper3.png)I love Python's
"[zip](https://docs.python.org/3/library/functions.html#zip)" function. I'm
not sure just what it is about zip that I enjoy, but I have often found it to
be quite useful. Before I describe what "zip" does, let me first show you an
example:

[code]

    >>> s = 'abc'
    >>> t = (10, 20, 30)
    
    >>> zip(s,t)
    [('a', 10), ('b', 20), ('c', 30)]
[/code]

As you can see, the result of "zip" is a sequence of tuples. (In Python 2, you
get a list back.  In Python 3, you get a "zip object" back.)  The tuple at
index 0 contains s[0] and t[0]. The tuple at index 1 contains s[1] and t[1].
And so forth.  You can use zip with more than one iterable, as well:

[code]

    >>> s = 'abc'
    >>> t = (10, 20, 30)
    >>> u = (-5, -10, -15)
    
    >>> list(zip(s,t,u))
    [('a', 10, -5), ('b', 20, -10), ('c', 30, -15)]
[/code]

(You can also invoke zip with a single iterable, thus ending up with a bunch
of one-element tuples, but that seems a bit weird to me.)

I often use "zip" to turn parallel sequences into dictionaries. For example:

[code]

    >>> names = ['Tom', 'Dick', 'Harry']
    >>> ages = [50, 35, 60]
    
    >>> dict(zip(names, ages))
    {'Harry': 60, 'Dick': 35, 'Tom': 50}
[/code]

In this way, we're able to quickly and easily product a dict from two parallel
sequences.

Whenever I mention "zip" in my programming classes, someone inevitably asks
what happens if one argument is shorter than the other. Simply put, the
shortest one wins:

[code]

    >>> s = 'abc'
    >>> t = (10, 20, 30, 40)
    >>> list(zip(s,t))
    [('a', 10), ('b', 20), ('c', 30)]
[/code]

(If you want zip to return one tuple for every element of the longer iterable,
then use "[izip_longest](https://docs.python.org/3/library/itertools.html#iter
tools.zip_longest)" from the
"[itertools](https://docs.python.org/3/library/itertools.html#module-
itertools)" package.)

Now, if there's something I like even more than "zip", it's list
comprehensions. So last week, when a student of mine asked if we could
implement "zip" using list comprehensions, I couldn't resist.

So, how can we do this?

First, let's assume that we have our two equal-length sequences from above, s
(a string) and t (a tuple). We want to get a list of three tuples. One way to
do this is to say:

[code]

    [(s[i], t[i])              # produce a two-element tuple
     for i in range(len(s))]   # from index 0 to len(s) - 1
[/code]

To be honest, this works pretty well! But there are a few ways in which we
could improve it.

First of all, it would be nice to make our comprehension-based "zip"
alternative handle inputs of different sizes.  What that means is not just
running range(len(s)), but running range(len(x)), where x is the shorter
sequence. We can do this via the "sorted" builtin function, telling it to sort
the sequences by length, from shortest to longest. For example:

[code]

    >>> s = 'abcd'
    >>> t = (10, 20, 30)
    
    >>> sorted((s,t), key=len)
    [(10, 20, 30), 'abcd']
[/code]

In the above code, I create a new tuple, (s,t), and pass that as the first
parameter to "sorted". Given these inputs, we will get a list back from
"sorted". Because we pass the builtin "len" function to the "key" parameter,
"sorted" will return [s,t] if s is shorter, and [t,s] if t is shorter.  This
means that the element at index 0 is guaranteed not to be longer than any
other sequence. (If all sequences are the same size, then we don't care which
one we get back.)

Putting this all together in our comprehension, we get:

[code]

    >>> [(s[i], t[i])    
        for i in range(len(sorted((s,t), key=len)[0]))]
    
[/code]

This is getting a wee bit complex for a single list comprehension, so I'm
going to break off part of the second line into a function, just to clean
things up a tiny bit:

[code]

    >>> def shortest_sequence_range(*args):
            return range(len(sorted(args, key=len)[0]))
    
    >>> [(s[i], t[i])     
        for i in shortest_sequence_range(s,t) ]
[/code]

Now, our function takes *args, meaning that it can take any number of
sequences. The sequences are sorted by length, and then the first (shortest)
sequence is passed to "len", which calculates the length and then returns the
result of running "range".

So if the shortest sequence is 'abc', we'll end up returning range(3), giving
us indexes 0, 1, and 2 — perfect for our needs.

Now, there's one thing left to do here to make it a bit closer to the real
"zip": As I mentioned above, Python 2's "zip" returns a list, but Python 3's
"zip" returns an iterator object. This means that even if the resulting list
would be extremely long, we won't use up tons of memory by returning it all at
once. Can we do that with our comprehension?

Yes, but not if we use a list comprehension, which always returns a list. If
we use a generator expression, by contrast, we'll get an iterator back, rather
than the entire list. Fortunately, creating such a generator expression is a
matter of just replacing the [ ] of our list comprehension with the ( ) of a
generator expression:

[code]

    >>> def shortest_sequence_range(*args):
          return range(len(sorted(args, key=len)[0]))
    
    >>> g = ((s[i], t[i])
             for i in shortest_sequence_range(s,t) )
    
    >>> for item in g:
            print(item)
    ('a', 10)
    ('b', 20)
    ('c', 30)
    
[/code]

And there you have it!  Further improvements on these ideas are welcome — but
as someone who loves both "zip" and comprehensions, it was fun to link these
two ideas together.

### Share this:

  * [LinkedIn](http://blog.lerner.co.il/implementing-zip-list-comprehensions/?share=linkedin "Click to share on LinkedIn" )
  * [Twitter](http://blog.lerner.co.il/implementing-zip-list-comprehensions/?share=twitter "Click to share on Twitter" )
  * [Reddit](http://blog.lerner.co.il/implementing-zip-list-comprehensions/?share=reddit "Click to share on Reddit" )
  * [Facebook](http://blog.lerner.co.il/implementing-zip-list-comprehensions/?share=facebook "Click to share on Facebook" )
  * [Google](http://blog.lerner.co.il/implementing-zip-list-comprehensions/?share=google-plus-1 "Click to share on Google+" )
  * 

Posted on [August 30, 2016August 31, 2016](http://blog.lerner.co.il
/implementing-zip-list-comprehensions/)Author [Reuven
Lerner](http://blog.lerner.co.il/author/reuven/)Categories
[Python](http://blog.lerner.co.il/category/python/)

##  17 thoughts on "Implementing "zip" with list comprehensions"

  1. ![](http://0.gravatar.com/avatar/fe9a66324584ab7743f081968b9938bc?s=56&d=mm&r=g) **Ryan** says:

[ August 30, 2016 at 11:20 pm  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32145)

It looks like there's a typo in the last example: "g" is a list comprehension
rather than a generator expression.

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32145#respond)

    1. ![](http://1.gravatar.com/avatar/4ef16ff17bbfb331c657d584ea0dc135?s=56&d=mm&r=g) **[Reuven Lerner](http://lerner.co.il)** says:

[ August 31, 2016 at 2:23 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32154)

Thanks; you're right, and I fixed that. The change was so simple that I forgot
to make it…

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32154#respond)

  2. ![](http://0.gravatar.com/avatar/92d3abdb8edce7f0af888c1266f5cd96?s=56&d=mm&r=g) **willem** says:

[ August 31, 2016 at 12:24 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32146)

I think it is much clearer to do:

min(len(item) for item in args)

instead of

len(sorted(args, key=len)[0])

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32146#respond)

    1. ![](http://1.gravatar.com/avatar/4ef16ff17bbfb331c657d584ea0dc135?s=56&d=mm&r=g) **[Reuven Lerner](http://lerner.co.il)** says:

[ August 31, 2016 at 2:21 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32152)

Ah, of course! I always forget that min and max take the "key" parameter, as
well. So I could instead say:

return range(len(min(args, key=len)))

and it'll be clearer, while doing the same thing.

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32152#respond)

  3. ![](http://1.gravatar.com/avatar/ab69055dbec51045b913cf64fc16d7d4?s=56&d=mm&r=g) **[caleb](http://pythonomicon.com)** says:

[ August 31, 2016 at 12:44 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32147)

Good article. For completeness you could add at the end a version of izip
where, instead of the list comprehension

g = [(s[i], t[i])  
for i in shortest_sequence_range(s,t) ]

you instead use the generator version:

g = ((s[i], t[i])  
for i in shortest_sequence_range(s,t))

The subsequent `for item in g` will work unchanged.

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32147#respond)

    1. ![](http://1.gravatar.com/avatar/ab69055dbec51045b913cf64fc16d7d4?s=56&d=mm&r=g) **[caleb](http://pythonomicon.com)** says:

[ August 31, 2016 at 12:46 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32148)

Oops. I see this is what you meant to say! The code snippet still needs to
have the brackets changed to parens. Sorry for the confusion.

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32148#respond)

      1. ![](http://1.gravatar.com/avatar/4ef16ff17bbfb331c657d584ea0dc135?s=56&d=mm&r=g) **[Reuven Lerner](http://lerner.co.il)** says:

[ August 31, 2016 at 2:16 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32151)

Whoops! Fixed. Thanks for noticing.

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32151#respond)

  4. ![](http://2.gravatar.com/avatar/b1f9b83e75aeb84843d48a7e53c8863c?s=56&d=mm&r=g) **David Goldfarb** says:

[ August 31, 2016 at 12:59 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32149)

Nice writeup.  
Take a look at Clojure too, where this style is the bread and butter of the
language.

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32149#respond)

    1. ![](http://1.gravatar.com/avatar/4ef16ff17bbfb331c657d584ea0dc135?s=56&d=mm&r=g) **[Reuven Lerner](http://lerner.co.il)** says:

[ August 31, 2016 at 2:29 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32155)

I've played with Clojure and loved what I saw, but haven't had time to do more
with it. But yes, that makes total sense.

When I mention to my students that this kind of functional style is typical in
Lisp, and that everyone should learn Lisp, there's a clear divide between the
people who learned Lisp (and generally dislike it, rolling their eyes at my
comment) and those who have no idea what I'm talking about. Good ol' 6.001,
which introduced me to Lisp (well, Scheme) brainwashed me, too!

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32155#respond)

  5. ![](http://1.gravatar.com/avatar/d6b9415353e04ffa6de5a8f3aaea0553?s=56&d=mm&r=g) **Terry Reedy** says:

[ August 31, 2016 at 2:12 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32150)

Built-in zip accepts iterables, not necessarily finite, and is not restricted
to sortable sequences. It is essentially the same as 2.x itertools.izip. The
generator code in the 2.x doc is quite simple and elegant.  
--  
def izip(*iterables):  
# izip('ABCD', 'xy') -&gt; Ax By  
iterators = map(iter, iterables)  
while iterators:  
yield tuple(map(next, iterators))  
--  
'while iterators' instead of 'while True' skips when there are no iterables.

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32150#respond)

    1. ![](http://1.gravatar.com/avatar/4ef16ff17bbfb331c657d584ea0dc135?s=56&d=mm&r=g) **[Reuven Lerner](http://lerner.co.il)** says:

[ August 31, 2016 at 2:30 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32156)

Ah, good point. I guess I hadn't thought about the possibility of zipping an
infinitely long iterable. I'd only suggest trying to sort an infinitely long
data structure if you're paid by the hour.

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32156#respond)

  6. ![](http://1.gravatar.com/avatar/dc105cdd75395154274f9da3d7612a9f?s=56&d=mm&r=g) **[Stephen Paul Chappell](https://plus.google.com/+StephenChappell)** says:

[ August 31, 2016 at 2:59 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32157)

Without importing anything, the following should work on just about any
sequence up to 18,446,744,073,709,551,616 items in length. It is important to
realize that zip does works on sequences that do not have any predetermined
size. If functions or imports were allowed and not just expressions, the code
could be easier to read and not quite as convoluted.

my_zip = lambda *sequences, generator=lambda iterators, cutoff=1&lt;&lt;64: (  
record for record in (tuple(next(  
iterator) for iterator in iterators) for _ in range(  
cutoff)) if record or next(iter(()))): generator(tuple(iter(  
sequence) for sequence in sequences))

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32157#respond)

  7. ![](http://2.gravatar.com/avatar/b2a84c6c50033df46d57faa1a5830532?s=56&d=mm&r=g) **Andrea R** says:

[ August 31, 2016 at 9:12 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32162)

Funniest comprehension in my opinion is a list flattener:  
&gt;&gt;&gt; x = [[1],[2],[3]]  
&gt;&gt;&gt; [x for x in x for x in x]  
[1, 2, 3]

Cheers

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32162#respond)

    1. ![](http://1.gravatar.com/avatar/4ef16ff17bbfb331c657d584ea0dc135?s=56&d=mm&r=g) **[Reuven Lerner](http://lerner.co.il)** says:

[ August 31, 2016 at 9:16 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32163)

That's great! While we're at it, we can even make it unpronounceable (a la
Slashdot):

[fore for fore in fore for fore in fore]  
[inn for inn in inn for inn in inn]  
[foreign for foreign in foreign for foreign in foreign]

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32163#respond)

  8. ![](http://1.gravatar.com/avatar/dc105cdd75395154274f9da3d7612a9f?s=56&d=mm&r=g) **[Stephen Paul Chappell](https://plus.google.com/+StephenChappell)** says:

[ August 31, 2016 at 4:39 pm  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32166)

My previous comment needs to be corrected. The code should be:

my_zip = lambda *a, b=lambda c, d, e=1&lt;&lt;64: (f for f in (tuple(next(g)
for g in c) for _ in range(e)) if len(f) == d or next(iter(()))):
b(tuple(iter(h) for h in a), len(a))

It was failing to work properly with some inputs. Here is one such test case:

list(my_zip(range(4), 'abc', b'AB'))

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32166#respond)

  9. ![](http://1.gravatar.com/avatar/176a7cd331d0327eb73ca631c26d8163?s=56&d=mm&r=g) **Larry Bugbee** says:

[ September 1, 2016 at 12:43 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32169)

Consider this: (both work under Python2 and Python3)  
&gt;&gt;&gt; s = 'abcde'  
&gt;&gt;&gt; t = (10, 20, 30)  
&gt;&gt;&gt; u = 'wxyz'  
&gt;&gt;&gt;  
&gt;&gt;&gt;  
&gt;&gt;&gt; # list ZIP  
… def my_ZIP(*args):  
… return [[j[i] for j in args] for i in range(len(min(args, key=len)))]  
…  
&gt;&gt;&gt; print(my_ZIP(s,t,u))  
[['a', 10, 'w'], ['b', 20, 'x'], ['c', 30, 'y']]  
&gt;&gt;&gt;  
&gt;&gt;&gt;  
&gt;&gt;&gt; # generator ZIP  
… def my_gZIP(*args):  
… return ([j[i] for j in args] for i in range(len(min(args, key=len))))  
…  
&gt;&gt;&gt; g = my_gZIP(s,t,u)  
&gt;&gt;&gt; print(g)  
&lt;generator object my_gZIP.. at 0x1013e19e8&gt;  
&gt;&gt;&gt; print([x for x in g])  
[['a', 10, 'w'], ['b', 20, 'x'], ['c', 30, 'y']]  
&gt;&gt;&gt;  
&gt;&gt;&gt;

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32169#respond)

    1. ![](http://1.gravatar.com/avatar/176a7cd331d0327eb73ca631c26d8163?s=56&d=mm&r=g) **Larry Bugbee** says:

[ September 1, 2016 at 2:19 am  ](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#comment-32170)

For better readability, change my_gZIP() to:

my_gZIP(*args):  
return ([a[i] for a in args] for i in range(len(min(args, key=len))))

[Reply](http://blog.lerner.co.il/implementing-zip-list-
comprehensions/?replytocom=32170#respond)

### Leave a Reply [Cancel reply](http://blog.lerner.co.il/implementing-zip-
list-comprehensions/#respond)

Your email address will not be published. Required fields are marked *

Comment

Name *

Email *

Website

Math Captcha  
twenty four ÷ = twenty four

Notify me of follow-up comments by email.

Notify me of new posts by email.

## Post navigation

[Previous Previous post: Fun with floats](http://blog.lerner.co.il/fun-with-
floats/)

[Proudly powered by WordPress](https://wordpress.org/)

  *[RSS]: Really Simple Syndication

